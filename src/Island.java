import java.util.Random;

//Класс объекта остров
public class Island {
    private Square[][] current; //хранит в себе массив - текущее состояние острова
    private Square[][] next; //хранит в себе массив - состояние острова, когда увеличиваем время на 1 единицу
    private static int sn = 40, rab = 20, gr = 10; //кол-во удавов, кроликов и травы
    public Island() { //конструктор, создает остров с первичным расположением всех животных и травы
        current = new Square[22][22];
        next = new Square[22][22];
        for (int i = 0; i < 22; i++) //цикл проходится по каждому элементу массива острова и заполняет его
            // пустыми клетками (и текущее, и следующее состояние острова)
            for (int j = 0; j < 22; j++)
                current[i][j] = next[i][j] = new Square(i, j);
        locateGrass(gr); //располагаем заданное кол-во травы
        locateSnake(sn); //располагаем заданное кол-во удавов
        locateRabbit(rab); //располагаем заданное кол-во кроликов
    }
    private void locateGrass(int amount) { //располагает траву на острове заданное кол-во раз,
        // в кач-ве параметров передаем кол-во объектов
        int k = 0; //счетчик, сколько объектов уже расположили
        int x_k, y_k; //координаты объекта, куда расположим его на острове
        Random r = new Random(); //рандомное число
        while (k < amount) { //пока не расположим заданное кол-во травы, генерируем случайные координаты
            x_k = r.nextInt(21 - 1) + 1;
            y_k = r.nextInt(21 - 1) + 1;
            if (current[x_k][y_k].getValue() == 0) { //если эта клетка ещё пуста,
                current[x_k][y_k] = new Grass(x_k, y_k); //то располагаем на её месте траву
                k++;
            }
        }
    }
    private void locateRabbit(int amount) { //располагает кроликов на острове заданное кол-во раз,
        // в кач-ве параметров передаем кол-во объектов
        int k = 0; //счетчик, сколько объектов уже расположили
        int x_k, y_k; //координаты объекта, куда расположим его на острове
        Random r = new Random(); //рандомное число
        while (k < amount) { //пока не расположим заданное кол-во кроликов, генерируем случайные координаты
            x_k = r.nextInt(21 - 1) + 1;
            y_k = r.nextInt(21 - 1) + 1;
            if (current[x_k][y_k].getValue() == 0) { //если эта клетка ещё пуста,
                current[x_k][y_k] = new Rabbit(x_k, y_k); //то располагаем на её месте кролика
                k++;
            }
        }
    }
    private void locateSnake(int amount) { //располагает удавов на острове заданное кол-во раз,
        // в кач-ве параметров передаем кол-во объектов
        int k = 0; //счетчик, сколько объектов уже расположили
        int x_k, y_k; //координаты объекта, куда расположим его на острове
        Random r = new Random(); //рандомное число
        while (k < amount) { //пока не расположим заданное кол-во удавов, генерируем случайные координаты
            x_k = r.nextInt(21 - 1) + 1;
            y_k = r.nextInt(21 - 1) + 1;
            if (current[x_k][y_k].getValue() == 0) { //если эта клетка ещё пуста,
                current[x_k][y_k] = new Snake(x_k, y_k); //то располагаем на её месте удава
                k++;
            }
        }
    }
    public Square[][] islandCur() { //возвращает текущее состояние острова
        return current;
    }

    public void printCur() { //выводит на экран текущее состояние острова
        for (int i = 1; i < 21; i++) { //в цикле проходимся по каждому объекту на острове и выводим
            for (int j = 1; j < 21; j++)
                current[i][j].print();
            System.out.println();
        }
    }

    public void update() { //обновление острова (+1 единица времени)
        Square[][] helper;//вспомогательный массив, чтобы корректно поменять ссылки текущего и следующего состояния
        for (int i = 1; i < 21; i++) //в цикле проходимся по каждому объекту на острове
            for (int j = 1; j < 21; j++)
                next[i][j] = current[i][j].nextStep(this); //и в next записываем измененный остров
        helper = current; //вспомогательный helper ссылаем на объекты массива текущего состояния
        current = next; //в current записываем измененный остров
        next = helper; //а в next - текущий (чтобы 2 переменной не ссылались на один массив объектов)
    }
}
